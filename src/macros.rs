// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License in the LICENSE-APACHE file or at:
//     https://www.apache.org/licenses/LICENSE-2.0

//! Library macros
//!
//! This documentation is provided as a reference. The macros may be easier to
//! understand from the example apps provided with `kas-wgpu`.
//!
//! This module provides two important macros:
//!
//! -   [`derive(Widget)`] implements the [`Widget`] trait (including associated
//!     traits like [`WidgetCore`] and optionally [`Handler`])
//! -   [`make_widget`] is a convenience macro to create a single instance of a
//!     custom widget type
//! -   [`derive(VoidMsg)`] is a convenience macro to implement
//!     `From<VoidMsg>` for the deriving type
//!
//! Note that these macros are defined in the external crate, `kas-macros`, only
//! because procedural macros must be defined in a special crate. The
//! `kas-macros` crate should not be used directly.
//!
//! Note further that these macros require gated functionality only available
//! in nightly `rustc` builds:
//! ```
//! #![feature(proc_macro_hygiene)]
//! ```
//!
//! [`make_widget`]: #the-make_widget-macro
//! [`derive(Widget)`]: #the-derivewidget-macro
//! [`derive(VoidMsg)`]: #the-derivevoidmsg-macro
//!
//!
//! ## The `derive(Widget)` macro
//!
//! The [`Widget`] trait requires the base trait [`WidgetCore`] be implemented;
//! additionally, widgets should implement [`Handler`]. This macro can generate
//! implementations for all of these traits or only for [`WidgetCore`] as
//! required.
//!
//! For parent widgets, the [`make_widget`] macro is even more concise.
//!
//! ### Type attributes
//!
//! This `derive` attribute may only be used on structs. This struct must have
//! a `#[widget]` attribute and may have a `#[handler]` attribute, as follows.
//!
//! ```notest
//! #[widget]
//! #[handler]
//! #[derive(Clone, Debug, Widget)]
//! struct MyWidget {
//!     ...
//! }
//! ```
//!
//! The `#[widget(..)]` attribute on the struct supports the following arguments:
//!
//! -   `layout = ...` (optional) — see below
//!
//! If the `layout` argument is missing, the [`Widget`] trait must be
//! implemented manually. If present, this trait will be implemented depending
//! on the `layout` argument's value:
//!
//! -   `single` — the widget wraps a single child, with no border or margin
//! -   `vertical` — child widgets are arranged in a vertical column
//! -   `horizontal` — child widgets are arranged in a horizontal row
//! -   `grid` — child widgets are arranged in a grid; see `#[widget]`
//!     attribute on fields and its arguments
//!
//! When deriving [`Widget`] with non-trivial layouts an extra data field is
//! required on the struct. This field should be specified as follows:
//! ```none
//! #[layout_data] layout_data: <Self as kas::LayoutData>::Data,
//! ```
//! This field is required for vertical, horizontal and grid layouts, and
//! optional otherwise. The type is generated by the macro and supports
//! `Default` and `Clone`, thus may be constructed with
//! `layout_data: Default::default()`.
//!
//! If there is a `#[handler]` attribute on the struct, then the [`Handler`]
//! trait will be implemented. This attribute accepts the following arguments:
//!
//! -   `msg = ...` — the [`Handler::Msg`] associated type; defaults to `()`
//! -   `generics = < X, Y, ... > where CONDS` — see below
//!
//! Commonly the [`Handler`] implementation requires extra bounds on generic
//! types, and sometimes also additional type parameters; the `generics`
//! argument allows this. This argument is optional and if present must be the
//! last argument. Note that the generic types and bounds given are *added to*
//! the generics defined on the struct itself.
//!
//! ### Fields
//!
//! One struct field with specification `#[core] core: CoreData` is required.
//!
//! A `#[widget]` attribute is used to denote fields as child widgets. This
//! attribute accepts the following optional arguments, for use with `grid`
//! layouts and for handlers:
//!
//! -   `col = ...` — grid column, from left (defaults to 0)
//! -   `row = ...` — grid row, from top (defaults to 0)
//! -   `cspan = ...` — number of columns to span (defaults to 1)
//! -   `rspan = ...` — number of rows to span (defaults to 1)
//! -   `handler = ...` — the name (`f`) of a method defined on this type which
//!     handles a message from the child (type `M`) and converts it to the
//!     appropriate response type for this widget (`R`); this method should have
//!     signature `fn f(&mut self, mgr: &mut Manager, msg: M) -> R`.
//!
//!
//! ### Examples
//!
//! A short example, without an implementation for [`Handler`] (which could
//! still be implemented separately):
//!
//! ```
//! use kas::macros::Widget;
//! use kas::{CoreData, LayoutData, Widget};
//!
//! #[widget(layout = single)]
//! #[derive(Debug, Widget)]
//! struct MyWidget<W: Widget> {
//!     #[core] core: CoreData,
//!     #[layout_data] layout_data: <Self as LayoutData>::Data,
//!     #[widget] child: W,
//! }
//! ```
//!
//! A longer example, including derivation of the [`Handler`] trait:
//!
//! ```
//! use kas::event::{Handler, Manager, VoidResponse, VoidMsg};
//! use kas::macros::Widget;
//! use kas::{CoreData, LayoutData, Widget};
//!
//! #[derive(Debug)]
//! enum ChildMessage { A }
//!
//! #[widget(layout = single)]
//! #[handler(generics = <> where W: Handler<Msg = ChildMessage>)]
//! #[derive(Debug, Widget)]
//! struct MyWidget<W: Widget> {
//!     #[core] core: CoreData,
//!     #[layout_data] layout_data: <Self as LayoutData>::Data,
//!     #[widget(handler = handler)] child: W,
//! }
//!
//! impl<W: Widget> MyWidget<W> {
//!     fn handler(&mut self, mgr: &mut Manager, msg: ChildMessage) -> VoidResponse {
//!         match msg {
//!             ChildMessage::A => { println!("handling ChildMessage::A"); }
//!         }
//!         VoidResponse::None
//!     }
//! }
//! ```
//!
//!
//! ## The `make_widget` macro
//!
//! This macro allows easy creation of "layout" widgets (those whose purpose is
//! to house one or more child widgets) by introducing syntax for a struct
//! literal and adding the additional fields and implementations required by all
//! widgets.
//!
//! Syntax is similar to a Rust type definition, but with most of the types and
//! identifiers omitted. It's easiest to study an example:
//!
//! ```rust
//! # #![feature(proc_macro_hygiene)]
//! # use kas::event::{VoidResponse, VoidMsg, Manager};
//! # use kas::macros::make_widget;
//! # use kas::widget::Label;
//! # let inner_widgets = Label::new("");
//! #[derive(Clone, Copy, Debug)]
//! enum Item {
//!     Button,
//!     Check(bool),
//! }
//! let widget = make_widget! {
//!     #[widget(layout = vertical)]
//!     #[handler(msg = VoidMsg)]
//!     struct {
//!         #[widget] _ = Label::from("Widget Gallery"),
//!         #[widget(handler = activations)] _ = inner_widgets,
//!         last_item: Item = Item::Button,
//!     }
//!     impl {
//!         fn activations(&mut self, mgr: &mut Manager, item: Item)
//!             -> VoidResponse
//!         {
//!             match item {
//!                 Item::Button => println!("Clicked!"),
//!                 Item::Check(b) => println!("Checkbox: {}", b),
//!             };
//!             self.last_item = item;
//!             VoidResponse::None
//!         }
//!     }
//! };
//! ```
//!
//! ### Struct and fields
//!
//! Starting from the middle, we have a `struct` definition, though two things
//! are unusual here: (1) the type is anonymous (unnamed), and (2) fields are
//! simultaneously given both type and value.
//!
//! Field specifications can get more unusual too, since both the field name and
//! the field type are optional. For example, all of the following are equivalent:
//!
//! ```nocompile
//! #[widget] l1: Label = Label::new("label 1"),
//! #[widget] _: Label = Label::new("label 2"),
//! #[widget] l3 = Label::new("label 3"),
//! #[widget] _ = Label::new("label 4"),
//! ```
//!
//! Omitting field names is fine, so long as you don't need to refer to them.
//! Omitting types, however, comes at a small cost: Rust does not support fields
//! of unspecified types, thus this must be emulated with generics. The macro
//! deals with the necessary type arguments to implementations, however macro
//! expansions (as sometimes seen in error messages) are ugly and, perhaps worst
//! of all, the field will have opaque type (making methods and inner fields
//! inaccessible). The latter can be partially remedied via trait bounds:
//!
//! ```nocompile
//! #[widget] display: impl HasText = EditBox::new("editable"),
//! ```
//!
//! ### Implementations
//!
//! Now, back to the example above, we see attributes and an `impl` block:
//!
//! ```nocompile
//! let widget = make_widget! {
//!     #[widget(layout = vertical)]
//!     #[handler(msg = VoidMsg)]
//!     struct {
//!         ...
//!     }
//!     impl {
//!         fn on_tick(&mut self, mgr: &mut Manager) {
//!             ...
//!         }
//!     }
//! };
//! ```
//!
//! Attributes may be applied to the anonymous struct like normal, with two
//! exceptions:
//!
//! 1.  `#[derive(Clone, Debug, kas::macros::Widget)]` is implied
//! 2.  `#[handler(msg = ..)]` is required and most only have an `msg` parameter
//!
//! `impl` blocks work like usual except that the struct name and type
//! parameters are omitted. Traits may also be implemented this way:
//!
//! ```nocompile
//! impl Trait { ... }
//! ```
//!
//! ### Example
//!
//! ```
//! #![feature(proc_macro_hygiene)]
//!
//! use kas::macros::{make_widget};
//! use kas::widget::TextButton;
//!
//! #[derive(Copy, Clone, Debug)]
//! enum OkCancel {
//!     Ok,
//!     Cancel,
//! }
//!
//! let button_box = make_widget!{
//!     #[handler(msg = OkCancel)]
//!     #[widget(layout = horizontal)]
//!     struct {
//!         #[widget] _ = TextButton::new("Ok", OkCancel::Ok),
//!         #[widget] _ = TextButton::new("Cancel", OkCancel::Cancel),
//!     }
//! };
//! ```
//!
//!
//! ## The `derive(VoidMsg)` macro
//!
//! This macro implements `From<VoidMsg>` for the given type (see [`VoidMsg`]).
//!
//! [`VoidMsg`]: crate::event::VoidMsg
//!
//! ### Example
//!
//! ```
//! use kas::macros::VoidMsg;
//!
//! #[derive(VoidMsg)]
//! enum MyMessage { A, B };
//! ```
//!
//! [`CoreData`]: crate::CoreData
//! [`Widget`]: crate::Widget
//! [`WidgetCore`]: crate::WidgetCore
//! [`Handler`]: crate::event::Handler
//! [`Handler::Msg`]: crate::event::Handler::Msg

pub use kas_macros::{make_widget, VoidMsg, Widget};
