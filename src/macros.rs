// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License in the LICENSE-APACHE file or at:
//     https://www.apache.org/licenses/LICENSE-2.0

//! Library macros
//!
//! This documentation is provided as a reference. The macros may be easier to
//! understand from the example apps provided with `kas-wgpu`.
//!
//! This module provides two important macros:
//!
//! -   [`derive(Widget)`] implements the [`Widget`] trait (including associated
//!     traits like [`WidgetCore`] and optionally [`Handler`])
//! -   [`make_widget`] is a convenience macro to create a single instance of a
//!     custom widget type
//! -   [`derive(VoidMsg)`] is a convenience macro to implement
//!     `From<VoidMsg>` for the deriving type
//!
//! Note that these macros are defined in the external crate, `kas-macros`, only
//! because procedural macros must be defined in a special crate. The
//! `kas-macros` crate should not be used directly.
//!
//! Note further that these macros require gated functionality only available
//! in nightly `rustc` builds:
//! ```
//! #![feature(proc_macro_hygiene)]
//! ```
//!
//! [`make_widget`]: #the-make_widget-macro
//! [`derive(Widget)`]: #the-derivewidget-macro
//! [`derive(VoidMsg)`]: #the-derivevoidmsg-macro
//!
//!
//! ## The `derive(Widget)` macro
//!
//! The [`Widget`] trait requires the base trait [`WidgetCore`] be implemented;
//! additionally, widgets should implement [`Handler`]. This macro can generate
//! implementations for all of these traits or only for [`WidgetCore`] as
//! required.
//!
//! For parent widgets, the [`make_widget`] macro is even more concise.
//!
//! ### Type attributes
//!
//! This `derive` attribute may only be used on structs. This struct must have
//! a `#[widget]` attribute and may have a `#[handler]` attribute, as follows.
//!
//! ```notest
//! #[widget]
//! #[handler]
//! #[derive(Clone, Debug, Widget)]
//! struct MyWidget {
//!     ...
//! }
//! ```
//!
//! The `#[widget(..)]` attribute on the struct supports the following arguments:
//!
//! -   `layout = ...` (optional) — see below
//!
//! If the `layout` argument is missing, the [`Widget`] trait must be
//! implemented manually. If present, this trait will be implemented depending
//! on the `layout` argument's value:
//!
//! -   `single` — the widget wraps a single child, with no border or margin
//! -   `vertical` — child widgets are arranged in a vertical column
//! -   `horizontal` — child widgets are arranged in a horizontal row
//! -   `grid` — child widgets are arranged in a grid; see `#[widget]`
//!     attribute on fields and its arguments
//!
//! When deriving [`Widget`] with non-trivial layouts an extra data field is
//! required on the struct. This field should be specified as follows:
//! ```none
//! #[layout_data] layout_data: <Self as kas::LayoutData>::Data,
//! ```
//! This field is required for vertical, horizontal and grid layouts, and
//! optional otherwise. The type is generated by the macro and supports
//! `Default` and `Clone`, thus may be constructed with
//! `layout_data: Default::default()`.
//!
//! If there is a `#[handler]` attribute on the struct, then the [`Handler`]
//! trait will be implemented. This attribute accepts the following arguments:
//!
//! -   `msg = ...` — the [`Handler::Msg`] associated type; defaults to `()`
//! -   `generics = < X, Y, ... > where CONDS` — see below
//!
//! Commonly the [`Handler`] implementation requires extra bounds on generic
//! types, and sometimes also additional type parameters; the `generics`
//! argument allows this. This argument is optional and if present must be the
//! last argument. Note that the generic types and bounds given are *added to*
//! the generics defined on the struct itself.
//!
//! ### Fields
//!
//! One struct field with specification `#[core] core: CoreData` is required.
//!
//! A `#[widget]` attribute is used to denote fields as child widgets. This
//! attribute accepts the following optional arguments, for use with `grid`
//! layouts and for handlers:
//!
//! -   `col = ...` — grid column, from left (defaults to 0)
//! -   `row = ...` — grid row, from top (defaults to 0)
//! -   `cspan = ...` — number of columns to span (defaults to 1)
//! -   `rspan = ...` — number of rows to span (defaults to 1)
//! -   `handler = ...` — the name (`f`) of a method defined on this type which
//!     handles a message from the child (type `M`) and converts it to the
//!     appropriate response type for this widget (`R`); this method should have
//!     signature `fn f(&mut self, tk: &TkWindow, msg: M) -> R`.
//!
//!
//! ### Examples
//!
//! A short example, without an implementation for [`Handler`] (which could
//! still be implemented separately):
//!
//! ```
//! use kas::macros::Widget;
//! use kas::{CoreData, LayoutData, Widget};
//!
//! #[widget(layout = single)]
//! #[derive(Debug, Widget)]
//! struct MyWidget<W: Widget> {
//!     #[core] core: CoreData,
//!     #[layout_data] layout_data: <Self as LayoutData>::Data,
//!     #[widget] child: W,
//! }
//! ```
//!
//! A longer example, including derivation of the [`Handler`] trait:
//!
//! ```
//! use kas::event::{Handler, VoidResponse, VoidMsg};
//! use kas::macros::Widget;
//! use kas::{CoreData, LayoutData, TkWindow, Widget};
//!
//! #[derive(Debug)]
//! enum ChildMessage { A }
//!
//! #[widget(layout = single)]
//! #[handler(generics = <> where W: Handler<Msg = ChildMessage>)]
//! #[derive(Debug, Widget)]
//! struct MyWidget<W: Widget> {
//!     #[core] core: CoreData,
//!     #[layout_data] layout_data: <Self as LayoutData>::Data,
//!     #[widget(handler = handler)] child: W,
//! }
//!
//! impl<W: Widget> MyWidget<W> {
//!     fn handler(&mut self, tk: &dyn TkWindow, msg: ChildMessage) -> VoidResponse {
//!         match msg {
//!             ChildMessage::A => { println!("handling ChildMessage::A"); }
//!         }
//!         VoidResponse::None
//!     }
//! }
//! ```
//!
//!
//! ## The `make_widget` macro
//!
//! This macro allows easy creation of "layout" widgets (those whose purpose is
//! to house one or more child widgets) by introducing syntax for a struct
//! literal and adding the additional fields and implementations required by all
//! widgets.
//!
//! Syntax should match the following Backus-Naur Form:
//!
//! ```bnf
//! <input>     ::= <layout> "=>" <msg> ";" <fields> ";" <funcs>
//! <layout>    ::= "frame" | "single" | "horizontal" | "vertical" | "grid"
//! <msg>  ::= <type>
//! <fields>    ::= "" | <field> | <field> "," <fields>
//! <field>     ::= <w_attr> <opt_ident> <field_ty> = <expr>
//! <opt_ident> ::= "_" | <ident>
//! <field_ty>  ::= "" | ":" <type> | ":" impl <bound> | "->" <type> | ":" impl <bound> "->" <type>
//! <w_attr>    ::= "" | "#" "[" <widget> <w_params> "]"
//! <w_params>  ::= "" | "(" <w_args> ")"
//! <w_args>    ::= <w_arg> | <w_arg> "," <w_args>
//! <w_arg>     ::= <pos_arg> "=" <lit> | "handler" = <ident>
//! <pos_arg>   ::= "col" | "row" | "cspan" | "rspan"
//! <funcs>     ::= "" | <func> <funcs>
//! ```
//! where `<type>` is a type expression, `<expr>` is a (value) expression,
//! `<ident>` is an identifier, `<lit>` is a literal, `<path>` is a path,
//! `<bound>` is a trait object bound, and
//! `<func>` is a Rust method definition. `""` is the empty string (i.e. nothing).
//!
//! The effect of this macro is to create an anonymous struct with the above
//! fields (plus an implicit `core`), implement [`WidgetCore`], [`Widget`]
//! and [`Handler`] (with the specified `<msg>` type), implement the
//! additional `<funcs>` listed on this type, then construct and return an
//! instance using the given value expressions to initialise each field.
//!
//! Each field is considered a child widget if the `#[widget]` attribute is
//! present, or a simple data field otherwise. The specification of this
//! attribute is identical to that used when deriving `Widget`.
//!
//! The `layout` specifier is as [above](#type-attributes).
//!
//! Fields may have an identifier or may be anonymous (via usage of `_`). This
//! is often convenient for child widgets which don't need to be referred to.
//!
//! Fields may have an explicit type (`ident : type = ...`), or the type may be
//! skipped, or (for widgets only) just the message type can be specified via
//! `ident -> type = ...`. Note that some type specification is usually needed
//! when referring to the field later.
//!
//! Optionally, a message handler may be specified for child widgets via
//! `#[widget(handler = f)] ident = value` where `f` is a method defined on the
//! anonymous struct with signature `fn f(&mut self, tk: &TkWindow, msg: M) -> R`
//! where `M` is the type of response received from the child widget, and `R` is
//! the type of response sent from this widget.
//!
//! ### Example
//!
//! ```
//! #![feature(proc_macro_hygiene)]
//!
//! use kas::macros::{make_widget};
//! use kas::widget::TextButton;
//!
//! #[derive(Copy, Clone, Debug)]
//! enum OkCancel {
//!     Ok,
//!     Cancel,
//! }
//!
//! let button_box = make_widget!{
//!     horizontal => OkCancel;
//!     struct {
//!         #[widget] _ = TextButton::new("Ok", OkCancel::Ok),
//!         #[widget] _ = TextButton::new("Cancel", OkCancel::Cancel),
//!     }
//! };
//! ```
//!
//!
//! ## The `derive(VoidMsg)` macro
//!
//! This macro implements `From<VoidMsg>` for the given type (see [`VoidMsg`]).
//!
//! [`VoidMsg`]: crate::event::VoidMsg
//!
//! ### Example
//!
//! ```
//! use kas::macros::VoidMsg;
//!
//! #[derive(VoidMsg)]
//! enum MyMessage { A, B };
//! ```
//!
//! [`CoreData`]: crate::CoreData
//! [`Widget`]: crate::Widget
//! [`WidgetCore`]: crate::WidgetCore
//! [`Handler`]: crate::event::Handler
//! [`Handler::Msg`]: crate::event::Handler::Msg

pub use kas_macros::{make_widget, VoidMsg, Widget};
