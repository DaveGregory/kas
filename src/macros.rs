// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License in the LICENSE-APACHE file or at:
//     https://www.apache.org/licenses/LICENSE-2.0

//! Library macros
//!
//! This documentation is provided as a reference. The macros may be easier to
//! understand from the example apps provided with `kas-rgx`.
//!
//! This module provides two important macros:
//!
//! -   [`derive(Widget)`] implements the [`Widget`] trait (including super-traits
//!     like [`Core`] and optionally [`Handler`])
//! -   [`make_widget`] is a convenience macro to create a single instance of a
//!     custom widget type
//! -   [`derive(EmptyMsg)`] is a convenience macro to implement
//!     `From<EmptyMsg>` for the deriving enum
//!
//! Note that these macros are defined in the external crate, `kas-macros`, only
//! because procedural macros must be defined in a special crate. The
//! `kas-macros` crate should not be used directly.
//!
//! Note further that these macros require gated functionality only available
//! in nightly `rustc` builds:
//! ```
//! #![feature(proc_macro_hygiene)]
//! ```
//!
//! [`make_widget`]: #the-make_widget-macro
//! [`derive(Widget)`]: #the-derivewidget-macro
//! [`derive(EmptyMsg)`]: #the-deriveemptymsg-macro
//!
//!
//! ## The `derive(Widget)` macro
//!
//! This macro is a core building block of the library to address the fact that
//! custom widget structs must implement several tedious traits whose details
//! are not necessary stable (or even public) parts of the API!
//!
//! Most users should prefer to use the [`make_widget`] macro.
//!
//! The [`Widget`] trait requires multiple base traits to be implemented:
//! [`Core`] and [`Layout`]. These base traits should be considered
//! implementation details and not used directly; this macro therefore
//! implements both base traits and [`Widget`] directly.
//!
//! Additionally, widgets are usually required to implement the [`Handler`]
//! trait. If (and only if) the deriving struct is marked with a
//! `#[handler]` attribute, the [`Handler`] trait will also be implemented.
//! Note that it is also possible to implement this trait manually.
//!
//! ### Type attributes
//!
//! This `derive` attribute may only be used on structs. This struct must have
//! a `#[widget]` attribute and may have a `#[handler]` attribute, as follows.
//!
//! ```notest
//! #[widget(class = Class::X, ...)]
//! #[handler]
//! #[derive(Clone, Debug, Widget)]
//! struct MyWidget {
//!     ...
//! }
//! ```
//!
//! The `#[widget]` attribute on the struct supports the following arguments:
//!
//! -   `class = ...` (required) — an expression yielding the widget's [`Class`]
//! -   `layout = ...` (optional) — see below
//!
//! If the `layout` argument is missing, the [`Layout`] trait must be
//! implemented manually. If present, this trait will be implemented depending
//! on the `layout` argument's value:
//!
//! -   `empty` — the widget displays no content and has zero size,
//!     except when expanded to fill empty space
//! -   `derive` — this is a simple widget with no children; content and
//!     dimensions are derived from the toolkit based on the widget's class
//! -   `single` — the widget wraps a single child, with no border or margin
//! -   `vertical` — child widgets are arranged in a vertical column
//! -   `horizontal` — child widgets are arranged in a horizontal row
//! -   `grid` — child widgets are arranged in a grid; see `#[widget]`
//!     attribute on fields and its arguments
//!
//! When deriving [`Layout`] with non-trivial layouts an extra data field is
//! required on the struct. This field should be specified as follows:
//! ```none
//! #[layout_data] layout_data: <Self as kas::LayoutData>::Data,
//! ```
//! This field is required for vertical, horizontal and grid layouts, and
//! optional otherwise. The type is generated by the macro and supports
//! `Default` and `Clone`, thus may be constructed with
//! `layout_data: Default::default()`.
//!
//! If there is a `#[handler]` attribute on the struct, then the [`Handler`]
//! trait will be implemented. This attribute accepts the following arguments:
//!
//! -   `msg = ...` — the [`Handler::Msg`] associated type; defaults to `()`
//! -   `generics = < X, Y, ... > where CONDS` — see below
//!
//! Commonly the [`Handler`] implementation requires extra bounds on generic
//! types, and sometimes also additional type parameters; the `generics`
//! argument allows this. This argument is optional and if present must be the
//! last argument. Note that the generic types and bounds given are *added to*
//! the generics defined on the struct itself.
//!
//! ### Fields
//!
//! One struct field must be marked with `#[core]` and implement the [`Core`]
//! trait; usually this field has the specification `#[core] core: CoreData`.
//!
//! A `#[widget]` attribute is used to denote fields as child widgets. This
//! attribute accepts the following optional arguments, for use with `grid`
//! layouts and for handlers:
//!
//! -   `col = ...` — grid column, from left (defaults to 0)
//! -   `row = ...` — grid row, from top (defaults to 0)
//! -   `cspan = ...` — number of columns to span (defaults to 1)
//! -   `rspan = ...` — number of rows to span (defaults to 1)
//! -   `handler = ...` — the name (`f`) of a method defined on this type which
//!     handles a message from the child (type `M`) and converts it to the
//!     appropriate response type for this widget (`R`); this method should have
//!     signature `fn f(&mut self, tk: &TkWindow, msg: M) -> R`.
//!
//!
//! ### Examples
//!
//! A short example, without an implementation for [`Handler`] (which could
//! still be implemented separately):
//!
//! ```
//! use kas::class::Class;
//! use kas::macros::Widget;
//! use kas::{Widget, CoreData};
//!
//! #[widget(class = Class::Window, layout = single)]
//! #[derive(Debug, Widget)]
//! struct MyWidget<W: Widget> {
//!     #[core] core: CoreData,
//!     #[widget] child: W,
//! }
//! ```
//!
//! A longer example, including derivation of the [`Handler`] trait:
//!
//! ```
//! use kas::class::Class;
//! use kas::event::{Handler, err_unhandled};
//! use kas::macros::{Widget, EmptyMsg};
//! use kas::{Widget, CoreData, TkWindow};
//!
//! #[derive(Debug, EmptyMsg)]
//! enum ChildMessage { None, A }
//!
//! #[derive(EmptyMsg)]
//! enum MyMessage { None }
//!
//! #[widget(class = Class::Container, layout = single)]
//! #[handler(msg = MyMessage,
//!         generics = <> where W: Handler<Msg = ChildMessage>)]
//! #[derive(Debug, Widget)]
//! struct MyWidget<W: Widget> {
//!     #[core] core: CoreData,
//!     #[widget(handler = handler)] child: W,
//! }
//!
//! impl<W: Widget> MyWidget<W> {
//!     fn handler(&mut self, tk: &dyn TkWindow, msg: ChildMessage) -> MyMessage {
//!         match msg {
//!             ChildMessage::None => (),
//!             ChildMessage::A => {
//!                 println!("handling ChildMessage::A");
//!             }
//!         }
//!         MyMessage::None
//!     }
//! }
//! ```
//!
//!
//! ## The `make_widget` macro
//!
//! This macro supports widgets of the following classes:
//!
//! -   Container
//! -   Frame
//!
//! This exists purely to save you some typing. You could instead make your own
//! struct, derive `Widget` (with attributes to enable Core, Layout and Widget
//! implementation), manually implement `event::Handler`, and instantiate an
//! object.
//!
//! Syntax should match the following Backus-Naur Form:
//!
//! ```bnf
//! <input>     ::= <class> "=>" <msg> ";" <fields> ";" <funcs>
//! <class>     ::= "container" "(" <layout> ")" | "frame"
//! <layout>    ::= "empty" | "derive" | "single" | "horizontal" | "vertical" | "grid"
//! <msg>  ::= <type>
//! <fields>    ::= "" | <field> | <field> "," <fields>
//! <field>     ::= <w_attr> <opt_ident> <field_ty> = <expr>
//! <opt_ident> ::= "_" | <ident>
//! <field_ty>  ::= "" | ":" <type> | ":" impl <bound> | "->" <type> | ":" impl <bound> "->" <type>
//! <w_attr>    ::= "" | "#" "[" <widget> <w_params> "]"
//! <w_params>  ::= "" | "(" <w_args> ")"
//! <w_args>    ::= <w_arg> | <w_arg> "," <w_args>
//! <w_arg>     ::= <pos_arg> "=" <lit> | "handler" = <ident>
//! <pos_arg>   ::= "col" | "row" | "cspan" | "rspan"
//! <funcs>     ::= "" | <func> <funcs>
//! ```
//! where `<type>` is a type expression, `<expr>` is a (value) expression,
//! `<ident>` is an identifier, `<lit>` is a literal, `<path>` is a path,
//! `<bound>` is a trait object bound, and
//! `<func>` is a Rust method definition. `""` is the empty string (i.e. nothing).
//!
//! The effect of this macro is to create an anonymous struct with the above
//! fields (plus an implicit `core`), implement [`Core`], [`Layout`], [`Widget`]
//! and [`Handler`] (with the specified `<msg>` type), implement the
//! additional `<funcs>` listed on this type, then construct and return an
//! instance using the given value expressions to initialise each field.
//!
//! Each field is considered a child widget if the `#[widget]` attribute is
//! present, or a simple data field otherwise. The specification of this
//! attribute is identical to that used when deriving `Widget`.
//!
//! The `layout` specifier is as [above](#type-attributes).
//!
//! Fields may have an identifier or may be anonymous (via usage of `_`). This
//! is often convenient for child widgets which don't need to be referred to.
//!
//! Fields may have an explicit type (`ident : type = ...`), or the type may be
//! skipped, or (for widgets only) just the message type can be specified via
//! `ident -> type = ...`. Note that some type specification is usually needed
//! when referring to the field later.
//!
//! Optionally, a message handler may be specified for child widgets via
//! `#[widget(handler = f)] ident = value` where `f` is a method defined on the
//! anonymous struct with signature `fn f(&mut self, tk: &TkWindow, msg: M) -> R`
//! where `M` is the type of response received from the child widget, and `R` is
//! the type of response sent from this widget.
//!
//! ### Example
//!
//! ```
//! #![feature(proc_macro_hygiene)]
//!
//! use kas::macros::{EmptyMsg, make_widget};
//! use kas::widget::TextButton;
//!
//! #[derive(Copy, Clone, Debug, EmptyMsg)]
//! enum OkCancel {
//!     None,
//!     Ok,
//!     Cancel,
//! }
//!
//! let button_box = make_widget!{
//!     container(horizontal) => OkCancel;
//!     struct {
//!         #[widget] _ = TextButton::new("Ok", OkCancel::Ok),
//!         #[widget] _ = TextButton::new("Cancel", OkCancel::Cancel),
//!     }
//! };
//! ```
//!
//!
//! ## The `derive(EmptyMsg)` macro
//!
//! This macro implements `From<EmptyMsg>` for the given type (see [`EmptyMsg`]).
//! It assumes that the type is an enum with a simple variant named `None`.
//!
//! [`EmptyMsg`]: crate::event::EmptyMsg
//!
//! ### Example
//!
//! ```
//! use kas::macros::EmptyMsg;
//!
//! #[derive(EmptyMsg)]
//! enum MyMessage { None, A, B };
//! ```
//!
//! [`Core`]: crate::Core
//! [`Layout`]: crate::Layout
//! [`Widget`]: crate::Widget
//! [`Handler`]: crate::event::Handler
//! [`Class`]: crate::class::Class
//! [`CoreData`]: crate::CoreData
//! [`Handler::Msg`]: ../kas/event/trait.Handler.html#associatedtype.Msg

pub use kas_macros::{make_widget, EmptyMsg, Widget};
