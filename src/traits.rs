// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License in the LICENSE-APACHE file or at:
//     https://www.apache.org/licenses/LICENSE-2.0

//! Widget traits

use std::fmt;
use std::time::Duration;

use crate::event::{Callback, Handler, Manager, UpdateHandle, VoidMsg};
use crate::geom::{Rect, Size};
use crate::layout::{self, AxisInfo, SizeRules};
use crate::theme::{DrawHandle, SizeHandle};
use crate::{CoreData, WidgetId};

pub trait CloneTo {
    unsafe fn clone_to(&self, out: *mut Self);
}

impl<T: Clone + Sized> CloneTo for T {
    unsafe fn clone_to(&self, out: *mut Self) {
        let x = self.clone();
        std::ptr::copy(&x, out, 1);
        std::mem::forget(x);
    }
}

/// Widget functionality implemented automatically
///
/// Certain details of the widget implementation can easily by generated by the
/// `derive(Widget)` macro. This trait covers that functionality.
///
/// It is not recommended to implement this manually since breaking changes may
/// be readily introduced (although not in patch releases).
pub trait WidgetCore: fmt::Debug {
    /// Get direct access to the [`CoreData`] providing property storage.
    fn core_data(&self) -> &CoreData;

    /// Get mutable access to the [`CoreData`] providing property storage.
    ///
    /// This should not normally be needed by user code.
    #[cfg_attr(not(feature = "internal_doc"), doc(hidden))]
    fn core_data_mut(&mut self) -> &mut CoreData;

    /// Get the widget's numeric identifier
    #[inline]
    fn id(&self) -> WidgetId {
        self.core_data().id
    }

    /// Get the widget's region, relative to its parent.
    #[inline]
    fn rect(&self) -> Rect {
        self.core_data().rect
    }

    /// Get the name of the widget struct
    fn widget_name(&self) -> &'static str;

    /// Erase type
    fn as_widget(&self) -> &dyn Widget;
    /// Erase type
    fn as_widget_mut(&mut self) -> &mut dyn Widget;

    /// Get the number of child widgets
    fn len(&self) -> usize;

    /// Get a reference to a child widget by index, or `None` if the index is
    /// out of bounds.
    ///
    /// For convenience, `Index<usize>` is implemented via this method.
    ///
    /// Required: `index < self.len()`.
    fn get(&self, index: usize) -> Option<&dyn Widget>;

    /// Mutable variant of get
    ///
    /// Warning: directly adjusting a widget without requiring reconfigure or
    /// redraw may break the UI. If a widget is replaced, a reconfigure **must**
    /// be requested. This can be done via [`Manager::send_action`].
    /// This method may be removed in the future.
    fn get_mut(&mut self, index: usize) -> Option<&mut dyn Widget>;

    /// Find a child widget by identifier
    ///
    /// This requires that the widget tree has already been configured by
    /// [`crate::event::ManagerState::configure`].
    fn find(&self, id: WidgetId) -> Option<&dyn Widget> {
        if id == self.id() {
            return Some(self.as_widget());
        } else if id > self.id() {
            return None;
        }

        for i in 0..self.len() {
            if let Some(w) = self.get(i) {
                if id > w.id() {
                    continue;
                }
                return w.find(id);
            }
            break;
        }
        None
    }

    /// Find a child widget by identifier
    ///
    /// This requires that the widget tree has already been configured by
    /// [`crate::event::ManagerState::configure`].
    fn find_mut(&mut self, id: WidgetId) -> Option<&mut dyn Widget> {
        if id == self.id() {
            return Some(self.as_widget_mut());
        } else if id > self.id() {
            return None;
        }

        for i in 0..self.len() {
            if self.get(i).map(|w| id > w.id()).unwrap_or(true) {
                continue;
            }
            if let Some(w) = self.get_mut(i) {
                return w.find_mut(id);
            }
            break;
        }
        None
    }

    /// Walk through all widgets, calling `f` once on each.
    ///
    /// This walk is iterative (nonconcurrent), depth-first, and always calls
    /// `f` on self *after* walking through all children.
    fn walk(&self, f: &mut dyn FnMut(&dyn Widget));

    /// Walk through all widgets, calling `f` once on each.
    ///
    /// This walk is iterative (nonconcurrent), depth-first, and always calls
    /// `f` on self *after* walking through all children.
    fn walk_mut(&mut self, f: &mut dyn FnMut(&mut dyn Widget));

    /// Debug tool: print the widget hierarchy
    #[deprecated(since = "0.2.0")]
    fn print_hierarchy(&self, depth: usize) {
        println!("{}\t{:?}\t{:?}", "- ".repeat(depth), self.id(), self.rect());
        for i in 0..self.len() {
            self.get(i).unwrap().print_hierarchy(depth + 1);
        }
    }
}

impl WidgetCore for Box<dyn Widget> {
    #[inline]
    fn core_data(&self) -> &CoreData {
        self.as_ref().core_data()
    }
    #[inline]
    fn core_data_mut(&mut self) -> &mut CoreData {
        self.as_mut().core_data_mut()
    }

    #[inline]
    fn widget_name(&self) -> &'static str {
        self.as_ref().widget_name()
    }

    #[inline]
    fn as_widget(&self) -> &dyn Widget {
        self.as_ref().as_widget()
    }
    #[inline]
    fn as_widget_mut(&mut self) -> &mut dyn Widget {
        self.as_mut().as_widget_mut()
    }

    #[inline]
    fn len(&self) -> usize {
        self.as_ref().len()
    }
    #[inline]
    fn get(&self, index: usize) -> Option<&dyn Widget> {
        self.as_ref().get(index)
    }
    #[inline]
    fn get_mut(&mut self, index: usize) -> Option<&mut dyn Widget> {
        self.as_mut().get_mut(index)
    }

    #[inline]
    fn walk(&self, f: &mut dyn FnMut(&dyn Widget)) {
        self.as_ref().walk(f);
    }
    #[inline]
    fn walk_mut(&mut self, f: &mut dyn FnMut(&mut dyn Widget)) {
        self.as_mut().walk_mut(f);
    }
}

/// Positioning and drawing routines for widgets
///
/// These methods are often implemented via a derive trait, hence live in their
/// own trait. (This may be revised in the future.)
pub trait Layout: WidgetCore {
    /// Get size rules for the given axis.
    ///
    /// This method takes `&mut self` to allow local caching of child widget
    /// configuration for future `size_rules` and `set_rect` calls.
    ///
    /// If operating on one axis and the other is fixed, then the `other`
    /// parameter is used for the fixed dimension. Additionally, one may assume
    /// that `size_rules` has previously been called on the fixed axis with the
    /// current widget configuration.
    fn size_rules(&mut self, size_handle: &mut dyn SizeHandle, axis: AxisInfo) -> SizeRules;

    /// Adjust to the given size.
    ///
    /// For many widgets this operation is trivial and the default
    /// implementation will suffice. For layout widgets (those with children),
    /// this operation is more complex.
    ///
    /// One may assume that `size_rules` has been called for each axis with the
    /// current widget configuration.
    #[inline]
    fn set_rect(&mut self, _size_handle: &mut dyn SizeHandle, rect: Rect) {
        self.core_data_mut().rect = rect;
    }

    /// Draw a widget
    ///
    /// This method is called to draw each visible widget (and should not
    /// attempt recursion on child widgets).
    fn draw(&self, draw_handle: &mut dyn DrawHandle, mgr: &Manager);
}

/// A widget is a UI element.
///
/// Widgets usually occupy space within the UI and are drawable. Widgets may
/// respond to user events. Widgets may have child widgets.
///
/// Widgets must implement the child trait [`WidgetCore`] and the
/// [`Handler`] trait, besides this trait.
/// It is recommended to use the `derive(Widget)` macro to generate some of the
/// required implementations. See documentation in the [`kas::macros`] module.
///
/// Example of a simple widget which draws a frame around its child:
///
/// ```
/// use kas::macros::Widget;
/// use kas::{CoreData, LayoutData, Widget};
///
/// #[widget]
/// #[layout(single, frame)]
/// #[derive(Clone, Debug, Widget)]
/// pub struct Frame<W: Widget> {
///     #[core] core: CoreData,
///     #[layout_data] layout_data: <Self as LayoutData>::Data,
///     #[widget] child: W,
/// }
/// ```
///
/// [`Handler`]: crate::event::Handler
pub trait Widget: Layout {
    /// Configure widget
    ///
    /// Widgets are *configured* on window creation and when
    /// [`kas::TkAction::Reconfigure`] is sent.
    ///
    /// This method is called immediately after assigning `self.core_data().id`.
    fn configure(&mut self, _: &mut Manager) {}

    /// Update the widget via a timer
    ///
    /// This method is called on scheduled updates (see [`update_on_timer`]).
    ///
    /// When some [`Duration`] is returned, another timed update is scheduled
    /// at approximately this duration from now (but without blocking redraws;
    /// usage of 1ns effectively enables per-frame update with FPS limited via
    /// VSync). Required: `duration > 0`.
    ///
    /// This method being called does not imply a redraw.
    ///
    /// [`update_on_timer`]: Manager::update_on_timer
    fn update_timer(&mut self, _: &mut Manager) -> Option<Duration> {
        None
    }

    /// Update the widget via an update handle
    ///
    /// This method is called on triggered updates (see [`update_on_handle`]).
    /// The source handle is specified via the [`UpdateHandle`] parameter.
    ///
    /// This method being called does not imply a redraw.
    ///
    /// [`update_on_handle`]: Manager::update_on_handle
    fn update_handle(&mut self, _: &mut Manager, _: UpdateHandle) {}

    /// Is this widget navigable via Tab key?
    fn allow_focus(&self) -> bool {
        false
    }
}

/// Trait to describe the type needed by the layout implementation.
///
/// To allow the `derive(Widget)` macro to implement [`Widget`], we use an
/// associated type to describe a data field of the following form:
/// ```none
/// #[layout_data] layout_data: <Self as kas::LayoutData>::Data,
/// ```
///
/// Ideally we would use an inherent associated type on the struct in question,
/// but until rust-lang#8995 is implemented that is not possible. We also cannot
/// place this associated type on the [`Widget`] trait itself, since then uses
/// of the trait would require parameterisation. Thus, this trait.
pub trait LayoutData {
    type Data: Clone + fmt::Debug + Default;
    type Solver: layout::RulesSolver;
    type Setter: layout::RulesSetter;
}

/// A window is a drawable interactive region provided by windowing system.
// TODO: should this be a trait, instead of simply a struct? Should it be
// implemented by dialogs? Note that from the toolkit perspective, it seems a
// Window should be a Widget. So alternatives are (1) use a struct instead of a
// trait or (2) allow any Widget to derive Window (i.e. implement required
// functionality with macros instead of the generic code below).
pub trait Window: Widget + Handler<Msg = VoidMsg> {
    /// Get the window title
    fn title(&self) -> &str;

    /// Adjust the size of the window, repositioning widgets.
    fn resize(&mut self, size_handle: &mut dyn SizeHandle, size: Size);

    /// Get a list of available callbacks.
    ///
    /// This returns a sequence of `(index, condition)` values. The toolkit
    /// should call `trigger_callback(index, mgr)` whenever the condition is met.
    fn callbacks(&self) -> Vec<(usize, Callback)>;

    /// Get the callback used on window closure.
    fn final_callback(&self) -> Option<&'static dyn Fn(Box<dyn kas::Window>, &mut Manager)>;

    /// Trigger a callback (see `iter_callbacks`).
    fn trigger_callback(&mut self, index: usize, mgr: &mut Manager);
}
